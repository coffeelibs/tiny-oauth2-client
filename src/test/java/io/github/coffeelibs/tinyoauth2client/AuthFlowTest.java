package io.github.coffeelibs.tinyoauth2client;

import io.github.coffeelibs.tinyoauth2client.http.RedirectTarget;
import io.github.coffeelibs.tinyoauth2client.http.response.Response;
import io.github.coffeelibs.tinyoauth2client.util.URIUtil;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.mockito.MockedStatic;
import org.mockito.Mockito;

import java.io.IOException;
import java.io.InterruptedIOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.function.Consumer;
import java.util.stream.Stream;

public class AuthFlowTest {

	private final TinyOAuth2Client client = Mockito.spy(new TinyOAuth2Client("my-client", URI.create("http://example.com/oauth2/token")));
	private final URI authEndpoint = URI.create("https://login.example.com/");
	private final PKCE pkce = new PKCE();

	@Nested
	@DisplayName("Configure")
	public class TestSetters {

		private AuthFlow authFlow;

		@BeforeEach
		public void setup() {
			authFlow = new AuthFlow(client, authEndpoint, pkce);
		}

		@Nested
		@DisplayName("successResponse")
		public class TestSuccessResponse {

			@Test
			@DisplayName("setSuccessResponse(null)")
			public void testNull() {
				Assertions.assertThrows(NullPointerException.class, () -> authFlow.setSuccessResponse(null));
			}

			@Test
			@DisplayName("setSuccessResponse(response)")
			public void testValidResponse() {
				var response = Response.empty(Response.Status.OK);

				Assertions.assertDoesNotThrow(() -> authFlow.setSuccessResponse(response));

				Assertions.assertEquals(response, authFlow.successResponse);
			}

		}

		@Nested
		@DisplayName("errorResponse")
		public class TestErrorResponse {

			@Test
			@DisplayName("setErrorResponse(null)")
			public void testNull() {
				Assertions.assertThrows(NullPointerException.class, () -> authFlow.setErrorResponse(null));
			}

			@Test
			@DisplayName("setErrorResponse(response)")
			public void testValidResponse() {
				var response = Response.empty(Response.Status.OK);

				Assertions.assertDoesNotThrow(() -> authFlow.setErrorResponse(response));

				Assertions.assertEquals(response, authFlow.errorResponse);
			}

		}

		@Nested
		@DisplayName("rediectPort")
		public class TestRedirectPort {

			@Test
			@DisplayName("defaults to AuthFlow.SYSTEM_ASSIGNED_PORT")
			public void testDefaultLocalPath() {
				Assertions.assertArrayEquals(AuthFlow.SYSTEM_ASSIGNED_PORT, authFlow.redirectPorts);
			}

			@Test
			@DisplayName("setRedirectPort(AuthFlow.SYSTEM_ASSIGNED_PORT)")
			public void testWithSystemAssignedLocalPort() {
				Assertions.assertDoesNotThrow(() -> authFlow.setRedirectPort(AuthFlow.SYSTEM_ASSIGNED_PORT));

				Assertions.assertArrayEquals(new int[]{0}, authFlow.redirectPorts);
			}

			@Test
			@DisplayName("setRedirectPort(null)")
			public void testWithNullLocalPort() {
				Assertions.assertThrows(NullPointerException.class, () -> authFlow.setRedirectPort((int[]) null));
			}

			@Test
			@DisplayName("setRedirectPort(1234, 5678)")
			public void testWithFixedLocalPorts() {
				Assertions.assertDoesNotThrow(() -> authFlow.setRedirectPort(1234, 5678));

				Assertions.assertArrayEquals(new int[]{1234, 5678}, authFlow.redirectPorts);
			}

		}

		@Nested
		@DisplayName("redirectPath")
		public class TestRedirectPath {

			@Test
			@DisplayName("defaults to autogenerated value")
			public void testDefaultLocalPath() {
				Assertions.assertTrue(authFlow.redirectPath.matches("/[\\w-]{16}"));
			}

			@Test
			@DisplayName("setRedirectPath(null)")
			public void testWithNullLocalPath() {
				//noinspection ConstantConditions
				Assertions.assertThrows(NullPointerException.class, () -> authFlow.setRedirectPath(null));
			}

			@Test
			@DisplayName("setRedirectPath(\"foo\")")
			public void testWithRelativeLocalPath() {
				Assertions.assertThrows(IllegalArgumentException.class, () -> authFlow.setRedirectPath("foo"));
			}

			@Test
			@DisplayName("setRedirectPath(\"/foo\")")
			public void testWithAbsoluteLocalPath() {
				Assertions.assertDoesNotThrow(() -> authFlow.setRedirectPath("/foo"));

				Assertions.assertEquals("/foo", authFlow.redirectPath);
			}
		}

	}

	@DisplayName("test buildAuthUri(...)")
	@ParameterizedTest(name = "buildAuthUri(\"{1}\", \"{2}\", {3})")
	@MethodSource
	public void testBuildAuthUri(URI authEndpoint, URI redirectEndpoint, String csrfToken, Set<String> scopes, URI expectedResult) {
		var pkce = Mockito.mock(PKCE.class);
		Mockito.doReturn("C0D3Ch4ll3ng3").when(pkce).getChallenge();
		var authFlow = new AuthFlow(client, authEndpoint, pkce);

		var result = authFlow.buildAuthUri(redirectEndpoint, csrfToken, scopes);

		Assertions.assertEquals(expectedResult.getScheme(), result.getScheme());
		Assertions.assertEquals(expectedResult.getAuthority(), result.getAuthority());
		Assertions.assertEquals(expectedResult.getPath(), result.getPath());
		// query order might differ:
		var expectedQueryParams = URIUtil.parseQueryString(expectedResult.getRawQuery());
		var queryParams = URIUtil.parseQueryString(result.getRawQuery());
		Assertions.assertEquals(expectedQueryParams, queryParams);
	}

	public static Stream<Arguments> testBuildAuthUri() {
		return Stream.of( //
				Arguments.of(URI.create("https://login.example.com/"), URI.create("http://127.0.0.1/callback"), "token", Set.of(), URI.create("https://login.example.com/?state=token&scope&code_challenge=C0D3Ch4ll3ng3&response_type=code&client_id=my-client&code_challenge_method=S256&redirect_uri=http%3A%2F%2F127.0.0.1%2Fcallback")), //
				Arguments.of(URI.create("https://login.example.com/?foo=bar"), URI.create("http://127.0.0.1/callback"), "token", Set.of(""), URI.create("https://login.example.com/?state=token&scope&code_challenge=C0D3Ch4ll3ng3&response_type=code&client_id=my-client&code_challenge_method=S256&redirect_uri=http%3A%2F%2F127.0.0.1%2Fcallback&foo=bar")), //
				Arguments.of(URI.create("https://login.example.com/"), URI.create("http://127.0.0.1/callback"), "t0k3n", Set.of("offline_access"), URI.create("https://login.example.com/?state=t0k3n&scope=offline_access&code_challenge=C0D3Ch4ll3ng3&response_type=code&client_id=my-client&code_challenge_method=S256&redirect_uri=http%3A%2F%2F127.0.0.1%2Fcallback")), //
				Arguments.of(URI.create("https://login.example.com/?foo=bar"), URI.create("http://127.0.0.1/callback"), "token", Set.of("offline_access"), URI.create("https://login.example.com/?state=token&scope=offline_access&code_challenge=C0D3Ch4ll3ng3&response_type=code&client_id=my-client&code_challenge_method=S256&redirect_uri=http%3A%2F%2F127.0.0.1%2Fcallback&foo=bar")), //
				Arguments.of(URI.create("https://login.example.com/?foo=bar"), URI.create("http://127.0.0.1/c?all=back"), "token", Set.of("offline_access"), URI.create("https://login.example.com/?state=token&scope=offline_access&code_challenge=C0D3Ch4ll3ng3&response_type=code&client_id=my-client&code_challenge_method=S256&redirect_uri=http%3A%2F%2F127.0.0.1%2Fc%3Fall%3Dback&foo=bar"))
		);
	}

	@Nested
	@SuppressWarnings("resource")
	@Timeout(1)
	@DisplayName("With configured AuthFlow")
	public class WithMockedRedirectTarget {

		private AuthFlow authFlow;
		private RedirectTarget redirectTarget;
		private MockedStatic<RedirectTarget> redirectTargetClass;
		private Consumer<URI> browser;

		@BeforeEach
		@SuppressWarnings({"unchecked"})
		public void setup() throws IOException {
			authFlow = new AuthFlow(client, authEndpoint, pkce);
			redirectTarget = Mockito.mock(RedirectTarget.class);
			redirectTargetClass = Mockito.mockStatic(RedirectTarget.class);
			redirectTargetClass.when(() -> RedirectTarget.start(Mockito.any(), Mockito.any())).thenReturn(redirectTarget);
			browser = Mockito.mock(Consumer.class);

			var redirected = new CountDownLatch(1);
			Mockito.doReturn(URI.create("http://127.0.0.1:1234/foo")).when(redirectTarget).getRedirectUri();
			Mockito.doReturn("csrf-token").when(redirectTarget).getCsrfToken();
			Mockito.doAnswer(invocation -> {
				redirected.await();
				return "authCode";
			}).when(redirectTarget).receive();
			Mockito.doAnswer(invocation -> {
				redirected.countDown();
				return null;
			}).when(browser).accept(Mockito.any());
		}

		@AfterEach
		public void tearDown() {
			redirectTargetClass.close();
		}

		@Test
		@DisplayName("requestAuthCode(...) uses configured path and ports")
		public void testAuthorizeWithFixedPathAndPorts() {
			authFlow.setRedirectPath("/foo").setRedirectPort(1234, 5678);

			Assertions.assertDoesNotThrow(() -> authFlow.requestAuthCode(browser));

			redirectTargetClass.verify(() -> RedirectTarget.start(authFlow.redirectPath, authFlow.redirectPorts));
		}

		@Test
		@DisplayName("requestAuthCode(...) calls redirectTarget.setSuccessResponse(...)")
		public void testApplySuccessResponse() {
			Assertions.assertDoesNotThrow(() -> authFlow.requestAuthCode(browser));

			Mockito.verify(redirectTarget).setSuccessResponse(authFlow.successResponse);
		}

		@Test
		@DisplayName("requestAuthCode(...) calls redirectTarget.setErrorResponse(...)")
		public void testApplyErrorResponse() {
			Assertions.assertDoesNotThrow(() -> authFlow.requestAuthCode(browser));

			Mockito.verify(redirectTarget).setErrorResponse(authFlow.errorResponse);
		}

		@Test
		@DisplayName("requestAuthCode(...) opens browser with URI returned from buildAuthUri(...)")
		public void testAuthorizeWithExistingQueryParams() throws IOException {
			var authFlow = Mockito.spy(new AuthFlow(client, authEndpoint, pkce));
			var completeUri = URI.create("https://login.example.com/?some&more&params");
			Mockito.doReturn(completeUri).when(authFlow).buildAuthUri(Mockito.any(), Mockito.any(), Mockito.any());

			var result = authFlow.requestAuthCode(browser);

			Assertions.assertInstanceOf(AuthFlow.AuthFlowWithCode.class, result);
			Mockito.verify(authFlow).buildAuthUri(redirectTarget.getRedirectUri(), redirectTarget.getCsrfToken(), Set.of());
			Mockito.verify(browser).accept(completeUri);
		}

		@Nested
		@DisplayName("After receiving auth code")
		public class WithAuthCode {

			@Test
			@DisplayName("buildTokenRequest() builds new http request")
			public void testBuildTokenRequest() {
				var authFlowWithCode = authFlow.new AuthFlowWithCode("redirect-uri", "auth-code");
				var request = Mockito.mock(HttpRequest.class);
				Mockito.doReturn(request).when(client).buildTokenRequest(Mockito.any());

				var result = authFlowWithCode.buildTokenRequest();

				Assertions.assertEquals(request, result);
				Mockito.verify(client).buildTokenRequest(Map.of(//
						"grant_type", "authorization_code", //
						"client_id", client.clientId, //
						"code_verifier", pkce.getVerifier(), //
						"code", "auth-code", //
						"redirect_uri", "redirect-uri" //
				));
			}

			@Test
			@DisplayName("getAccessToken() sends access token request")
			public void testGetAccessToken() throws IOException, InterruptedException {
				var authFlowWithCode = Mockito.spy(authFlow.new AuthFlowWithCode("redirect-uri", "auth-code"));
				var httpClient = Mockito.mock(HttpClient.class);
				var httpRequest = Mockito.mock(HttpRequest.class);
				var httpRespone = Mockito.mock(HttpResponse.class);
				try (var httpClientClass = Mockito.mockStatic(HttpClient.class)) {
					httpClientClass.when(HttpClient::newHttpClient).thenReturn(httpClient);
					Mockito.doReturn(httpRequest).when(authFlowWithCode).buildTokenRequest();
					Mockito.doReturn(httpRespone).when(httpClient).send(Mockito.any(), Mockito.any());

					var result = authFlowWithCode.getAccessToken();

					Assertions.assertEquals(httpRespone, result);
					Mockito.verify(authFlowWithCode).buildTokenRequest();
					Mockito.verify(httpClient).send(httpRequest, HttpResponse.BodyHandlers.ofString());
				}
			}

		}

	}

	@Test
	@DisplayName("authorize(...) runs requestAuthCode() and getAccessToken()")
	@SuppressWarnings("unchecked")
	public void testAuthorize() throws IOException, InterruptedException {
		Consumer<URI> browser = Mockito.mock(Consumer.class);
		var authFlow = Mockito.spy(new AuthFlow(client, authEndpoint, pkce));
		var authFlowWithCode = Mockito.mock(AuthFlow.AuthFlowWithCode.class);
		var httpResponse = Mockito.mock(HttpResponse.class);
		Mockito.doReturn(authFlowWithCode).when(authFlow).requestAuthCode(Mockito.any(), Mockito.any());
		Mockito.doReturn(httpResponse).when(authFlowWithCode).getAccessToken();

		var result = authFlow.authorize(browser);

		Assertions.assertEquals(httpResponse, result);
	}

	@Test
	@DisplayName("authorize() throws InterruptedIOException when getAccessToken() throws InterruptedException")
	@SuppressWarnings("unchecked")
	public void testInterruptAuthorize() throws IOException, InterruptedException {
		Consumer<URI> browser = Mockito.mock(Consumer.class);
		var authFlow = Mockito.spy(new AuthFlow(client, authEndpoint, pkce));
		var authFlowWithCode = Mockito.mock(AuthFlow.AuthFlowWithCode.class);
		Mockito.doReturn(authFlowWithCode).when(authFlow).requestAuthCode(Mockito.any(), Mockito.any());
		Mockito.doThrow(new InterruptedException()).when(authFlowWithCode).getAccessToken();

		Assertions.assertThrows(InterruptedIOException.class, () -> authFlow.authorize(browser));
	}

}